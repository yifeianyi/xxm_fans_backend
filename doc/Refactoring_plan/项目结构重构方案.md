# XXM Fans Home 项目结构重构方案

## 一、现状分析

### 1.1 当前应用架构

```
xxm_fans_backend/
├── song_management/      # 歌曲管理（咻咻满）
├── fansDIY/             # 粉丝二创作品
├── data_analytics/      # 数据分析（独立数据库 view_data_db）
├── site_settings/       # 网站设置+推荐语
├── bilibili_integration/# B站集成
└── songlist/            # 模板化歌单（独立数据库 songlist_db）
```

### 1.2 数据库配置

- `db.sqlite3`：主数据库（song_management、fansDIY、site_settings、bilibili_integration）
- `view_data.sqlite3`：数据分析数据库（已废弃）
- `songlist.sqlite3`：模板化歌单数据库（数据有问题，需要重建）

### 1.3 核心问题

1. **数据库混乱**：view_data_db已废弃但未清理，songlist_db数据有问题
2. **songlist定位**：是模板化歌单，支持多歌手复用同一套API，需要通过singer_name字段区分
3. **缺少服务层**：业务逻辑直接写在views中，不够清晰
4. **缺少统一规范**：响应格式、异常处理等不统一

## 二、重构目标

1. **清理数据库**：删除废弃的view_data_db，重建songlist_db
2. **songlist模板化**：添加singer_name字段，支持多歌手
3. **引入服务层**：业务逻辑与数据访问分离
4. **统一规范**：标准化API响应、异常处理
5. **保持简洁**：不引入不必要的抽象层次

## 三、重构方案

### 3.1 数据库配置

```python
# settings.py
DATABASES = {
    # 核心业务数据库
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
        'OPTIONS': {'timeout': 20}
    },
    # 模板化歌单数据库（独立）
    'songlist_db': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'songlist.sqlite3',
        'OPTIONS': {'timeout': 20}
    }
}

# 数据库路由
DATABASE_ROUTERS = ['xxm_fans_home.db_routers.MultiDbRouter']
```

### 3.2 songlist模型重构

```python
# songlist/models.py
from django.db import models


class Songlist(models.Model):
    """模板化歌单 - 支持多歌手"""
    singer_name = models.CharField(
        max_length=100,
        verbose_name="歌手标识",
        help_text="如：youyou、bingjie"
    )
    song_name = models.CharField(max_length=200, verbose_name='歌曲名称')
    singer = models.CharField(max_length=100, verbose_name='歌手')
    language = models.CharField(max_length=50, verbose_name='语言')
    style = models.CharField(max_length=50, verbose_name='曲风')
    note = models.TextField(blank=True, verbose_name='备注')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        verbose_name = '模板化歌单'
        verbose_name_plural = '模板化歌单'
        ordering = ['singer_name', 'song_name']
        unique_together = ('singer_name', 'song_name')
        indexes = [
            models.Index(fields=['singer_name', 'song_name']),
            models.Index(fields=['singer_name', 'language']),
        ]

    def __str__(self):
        return f"[{self.singer_name}] {self.song_name}"


class SonglistSiteSetting(models.Model):
    """歌单网站设置 - 支持多歌手"""
    singer_name = models.CharField(max_length=100, verbose_name="歌手标识")
    photo_url = models.CharField(max_length=500, verbose_name='图片URL')
    position = models.IntegerField(
        choices=[(1, '头像图标'), (2, '背景图片')]
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        verbose_name = '歌单网站设置'
        unique_together = ('singer_name', 'position')

    def __str__(self):
        return f"[{self.singer_name}] 设置"
```

### 3.3 songlist服务层

```python
# songlist/services.py
from typing import List, Optional
from .models import Songlist, SonglistSiteSetting


class SonglistService:
    """歌单服务"""

    @staticmethod
    def get_songs_by_singer(singer_name: str, **filters) -> List[Songlist]:
        """根据歌手获取歌曲"""
        return Songlist.objects.filter(singer_name=singer_name, **filters)

    @staticmethod
    def get_all_singers() -> List[str]:
        """获取所有歌手列表"""
        return Songlist.objects.values_list('singer_name', flat=True).distinct()

    @staticmethod
    def get_languages(singer_name: str) -> List[str]:
        """获取歌手的语言列表"""
        return Songlist.objects.filter(
            singer_name=singer_name
        ).values_list('language', flat=True).distinct()

    @staticmethod
    def get_styles(singer_name: str) -> List[str]:
        """获取歌手的曲风列表"""
        return Songlist.objects.filter(
            singer_name=singer_name
        ).values_list('style', flat=True).distinct()

    @staticmethod
    def get_random_song(singer_name: str) -> Optional[Songlist]:
        """获取随机歌曲"""
        return Songlist.objects.filter(
            singer_name=singer_name
        ).order_by('?').first()


class SonglistSiteSettingService:
    """网站设置服务"""

    @staticmethod
    def get_settings(singer_name: str) -> List[SonglistSiteSetting]:
        """获取歌手的网站设置"""
        return SonglistSiteSetting.objects.filter(singer_name=singer_name)
```

### 3.4 songlist API视图

```python
# songlist/api_views.py
from rest_framework.decorators import api_view
from rest_framework.response import Response
from rest_framework.exceptions import ValidationError
from .models import Songlist, SonglistSiteSetting
from .serializers import SonglistSerializer, SonglistSiteSettingSerializer
from .services import SonglistService, SonglistSiteSettingService


@api_view(['GET'])
def song_list(request):
    """歌曲列表 - 需要singer_name参数"""
    singer_name = request.GET.get('singer_name')
    if not singer_name:
        raise ValidationError("缺少singer_name参数")

    songs = SonglistService.get_songs_by_singer(singer_name)
    serializer = SonglistSerializer(songs, many=True)
    return Response({'code': 200, 'data': serializer.data})


@api_view(['GET'])
def language_list(request):
    """语言列表 - 需要singer_name参数"""
    singer_name = request.GET.get('singer_name')
    if not singer_name:
        raise ValidationError("缺少singer_name参数")

    languages = SonglistService.get_languages(singer_name)
    return Response({'code': 200, 'data': languages})


@api_view(['GET'])
def style_list(request):
    """曲风列表 - 需要singer_name参数"""
    singer_name = request.GET.get('singer_name')
    if not singer_name:
        raise ValidationError("缺少singer_name参数")

    styles = SonglistService.get_styles(singer_name)
    return Response({'code': 200, 'data': styles})


@api_view(['GET'])
def random_song(request):
    """随机歌曲 - 需要singer_name参数"""
    singer_name = request.GET.get('singer_name')
    if not singer_name:
        raise ValidationError("缺少singer_name参数")

    song = SonglistService.get_random_song(singer_name)
    if not song:
        return Response({'code': 404, 'message': '暂无歌曲数据'})

    serializer = SonglistSerializer(song)
    return Response({'code': 200, 'data': serializer.data})


@api_view(['GET'])
def site_settings(request):
    """网站设置 - 需要singer_name参数"""
    singer_name = request.GET.get('singer_name')
    if not singer_name:
        raise ValidationError("缺少singer_name参数")

    settings = SonglistSiteSettingService.get_settings(singer_name)
    serializer = SonglistSiteSettingSerializer(settings, many=True)
    return Response({'code': 200, 'data': serializer.data})
```

### 3.5 数据库路由

```python
# xxm_fans_home/db_routers.py
class MultiDbRouter:
    """多数据库路由器"""

    def db_for_read(self, model, **hints):
        if model._meta.app_label == 'songlist':
            return 'songlist_db'
        return 'default'

    def db_for_write(self, model, **hints):
        if model._meta.app_label == 'songlist':
            return 'songlist_db'
        return 'default'

    def allow_relation(self, obj1, obj2, **hints):
        return obj1._state.db == obj2._state.db

    def allow_migrate(self, db, app_label, model_name=None, **hints):
        if app_label == 'songlist':
            return db == 'songlist_db'
        return db == 'default'
```

### 3.6 数据迁移脚本

```python
# tools/migrate_songlist.py
import os
import django
import sqlite3

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'xxm_fans_home.settings')
django.setup()

from songlist.models import Songlist, SonglistSiteSetting


def migrate_from_db():
    """从db.sqlite3迁移songlist数据"""
    conn = sqlite3.connect('db.sqlite3')
    cursor = conn.cursor()

    # 迁移bingjie数据
    cursor.execute("SELECT * FROM bingjie_SongList_bingjie_songs")
    for row in cursor.fetchall():
        Songlist.objects.using('songlist_db').create(
            singer_name='bingjie',
            song_name=row[1],
            singer=row[2],
            language=row[3],
            style=row[4],
            note=row[5]
        )

    # 迁移youyou数据
    cursor.execute("SELECT * FROM youyou_SongList_you_songs")
    for row in cursor.fetchall():
        Songlist.objects.using('songlist_db').create(
            singer_name='youyou',
            song_name=row[1],
            singer=row[2],
            language=row[3],
            style=row[4],
            note=row[5]
        )

    # 迁移网站设置
    cursor.execute("SELECT * FROM bingjie_SongList_bingjie_site_setting")
    for row in cursor.fetchall():
        SonglistSiteSetting.objects.using('songlist_db').create(
            singer_name='bingjie',
            photo_url=row[1],
            position=row[2]
        )

    cursor.execute("SELECT * FROM youyou_SongList_you_site_setting")
    for row in cursor.fetchall():
        SonglistSiteSetting.objects.using('songlist_db').create(
            singer_name='youyou',
            photo_url=row[1],
            position=row[2]
        )

    conn.close()
    print("迁移完成")


if __name__ == '__main__':
    migrate_from_db()
```

## 四、实施步骤

### 阶段1：数据库清理（1天）

1. 备份所有数据库文件
2. 删除 `view_data.sqlite3`
3. 删除有问题的 `songlist.sqlite3`

### 阶段2：songlist重构（2-3天）

1. 修改songlist模型，添加singer_name字段
2. 创建新的songlist.sqlite3
3. 编写并运行数据迁移脚本
4. 测试API的singer_name筛选功能

### 阶段3：服务层引入（3-5天）

1. 为songlist添加服务层
2. 为其他应用逐步添加服务层
3. 重构views使用服务层
4. 统一API响应格式

### 阶段4：清理优化（1-2天）

1. 删除旧的bilibili_integration导入历史模型
2. 更新文档
3. 清理无用代码

**总计：7-11个工作日**

## 五、关键要点

1. **songlist是模板化业务**：支持多歌手，独立数据库，通过singer_name字段区分
2. **不引入core模块**：保持简洁，工具类放在utils目录
3. **integration不记录历史**：只保留服务层和适配器
4. **数据库分离合理**：核心业务统一，模板化业务独立
5. **服务层渐进式引入**：从songlist开始，逐步推广到其他应用

## 六、API调用示例

```bash
# 获取bingjie的歌曲列表
GET /api/songlist/songs/?singer_name=bingjie

# 获取youyou的语言列表
GET /api/songlist/languages/?singer_name=youyou

# 获取bingjie的随机歌曲
GET /api/songlist/random-song/?singer_name=bingjie

# 获取youyou的网站设置
GET /api/songlist/site-settings/?singer_name=youyou
```